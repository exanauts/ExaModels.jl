<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example: Distillation Column · ExaModels.jl</title><meta name="title" content="Example: Distillation Column · ExaModels.jl"/><meta property="og:title" content="Example: Distillation Column · ExaModels.jl"/><meta property="twitter:title" content="Example: Distillation Column · ExaModels.jl"/><meta name="description" content="Documentation for ExaModels.jl."/><meta property="og:description" content="Documentation for ExaModels.jl."/><meta property="twitter:description" content="Documentation for ExaModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ExaModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExaModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../simd/">Mathematical Abstraction</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorial</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../guide/">Getting Started</a></li><li><a class="tocitem" href="../performance/">Performance Tips</a></li><li><a class="tocitem" href="../gpu/">CPU and GPU acceleration</a></li><li><a class="tocitem" href="../parameters/">Parameters</a></li><li><a class="tocitem" href="../develop/">Developing Extensions</a></li><li><a class="tocitem" href="../quad/">Example: Quadrotor</a></li><li class="is-active"><a class="tocitem" href>Example: Distillation Column</a><ul class="internal"><li><a class="tocitem" href="#Subexpressions-in-ExaModels"><span>Subexpressions in ExaModels</span></a></li><li><a class="tocitem" href="#Trade-offs:-Lifted-vs-Reduced"><span>Trade-offs: Lifted vs Reduced</span></a></li><li><a class="tocitem" href="#Performance-Comparison-(T10)"><span>Performance Comparison (T=10)</span></a></li><li><a class="tocitem" href="#Original-Model-(without-subexpressions)"><span>Original Model (without subexpressions)</span></a></li><li><a class="tocitem" href="#Model-with-Subexpressions-(Moderate)"><span>Model with Subexpressions (Moderate)</span></a></li><li><a class="tocitem" href="#Compact-Model-with-Aggressive-Subexpressions"><span>Compact Model with Aggressive Subexpressions</span></a></li><li><a class="tocitem" href="#Model-with-Reduced-Subexpressions-(Moderate)"><span>Model with Reduced Subexpressions (Moderate)</span></a></li><li><a class="tocitem" href="#Compact-Model-with-Aggressive-Reduced-Subexpressions"><span>Compact Model with Aggressive Reduced Subexpressions</span></a></li><li><a class="tocitem" href="#Running-the-Models"><span>Running the Models</span></a></li><li><a class="tocitem" href="#Comparison-Results"><span>Comparison Results</span></a></li></ul></li><li><a class="tocitem" href="../opf/">Example: Optimal Power Flow</a></li></ul></li><li><a class="tocitem" href="../jump/">JuMP Interface (experimental)</a></li><li><a class="tocitem" href="../core/">API Manual</a></li><li><a class="tocitem" href="../ref/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Example: Distillation Column</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example: Distillation Column</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/exanauts/ExaModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/exanauts/ExaModels.jl/blob/main/docs/src/distillation.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="distillation"><a class="docs-heading-anchor" href="#distillation">Example: Distillation Column</a><a id="distillation-1"></a><a class="docs-heading-anchor-permalink" href="#distillation" title="Permalink"></a></h1><p>This example demonstrates the use of <code>subexpr</code> to simplify complex models. We show five versions of a distillation column model comparing lifted vs reduced subexpressions.</p><h2 id="Subexpressions-in-ExaModels"><a class="docs-heading-anchor" href="#Subexpressions-in-ExaModels">Subexpressions in ExaModels</a><a id="Subexpressions-in-ExaModels-1"></a><a class="docs-heading-anchor-permalink" href="#Subexpressions-in-ExaModels" title="Permalink"></a></h2><p>ExaModels provides the <code>subexpr</code> function to define reusable expressions in two forms:</p><p><strong>Lifted subexpressions</strong> (default): Creates auxiliary variables with defining equality constraints.</p><pre><code class="language-julia hljs">s = subexpr(c, x[i]^2 for i in 1:n)  # adds n variables + n constraints</code></pre><p><strong>Reduced subexpressions</strong>: Inlines the expression directly, no extra variables or constraints.</p><pre><code class="language-julia hljs">s = subexpr(c, x[i]^2 for i in 1:n; reduced=true)  # no extra vars/cons</code></pre><h2 id="Trade-offs:-Lifted-vs-Reduced"><a class="docs-heading-anchor" href="#Trade-offs:-Lifted-vs-Reduced">Trade-offs: Lifted vs Reduced</a><a id="Trade-offs:-Lifted-vs-Reduced-1"></a><a class="docs-heading-anchor-permalink" href="#Trade-offs:-Lifted-vs-Reduced" title="Permalink"></a></h2><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">Lifted</th><th style="text-align: right">Reduced</th></tr><tr><td style="text-align: right"><strong>Problem size</strong></td><td style="text-align: right">Adds auxiliary vars/cons</td><td style="text-align: right">No extra vars/cons</td></tr><tr><td style="text-align: right"><strong>Expression complexity</strong></td><td style="text-align: right">Simple variable references</td><td style="text-align: right">Inlined expressions</td></tr><tr><td style="text-align: right"><strong>Derivative code</strong></td><td style="text-align: right">Generated once per pattern</td><td style="text-align: right">Regenerated at each use</td></tr><tr><td style="text-align: right"><strong>Nesting</strong></td><td style="text-align: right">Robust</td><td style="text-align: right">Works with fixed indexing bug</td></tr><tr><td style="text-align: right"><strong>Convergence</strong></td><td style="text-align: right">May need more iterations</td><td style="text-align: right">Same as original</td></tr></table><h2 id="Performance-Comparison-(T10)"><a class="docs-heading-anchor" href="#Performance-Comparison-(T10)">Performance Comparison (T=10)</a><a id="Performance-Comparison-(T10)-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Comparison-(T10)" title="Permalink"></a></h2><table><tr><th style="text-align: right">Model</th><th style="text-align: right">Variables</th><th style="text-align: right">Constraints</th><th style="text-align: right">Iterations</th></tr><tr><td style="text-align: right">Original (no subexpr)</td><td style="text-align: right">737</td><td style="text-align: right">726</td><td style="text-align: right">7</td></tr><tr><td style="text-align: right">Moderate lifted</td><td style="text-align: right">1398</td><td style="text-align: right">1387</td><td style="text-align: right">7</td></tr><tr><td style="text-align: right">Aggressive lifted</td><td style="text-align: right">1409</td><td style="text-align: right">1398</td><td style="text-align: right">14</td></tr><tr><td style="text-align: right">Moderate reduced</td><td style="text-align: right">737</td><td style="text-align: right">726</td><td style="text-align: right">7</td></tr><tr><td style="text-align: right">Aggressive reduced</td><td style="text-align: right">715</td><td style="text-align: right">704</td><td style="text-align: right">7</td></tr></table><p>All five models converge to the same optimal solution. Reduced subexpressions maintain the original problem size while providing the code clarity benefits of subexpressions.</p><h2 id="Original-Model-(without-subexpressions)"><a class="docs-heading-anchor" href="#Original-Model-(without-subexpressions)">Original Model (without subexpressions)</a><a id="Original-Model-(without-subexpressions)-1"></a><a class="docs-heading-anchor-permalink" href="#Original-Model-(without-subexpressions)" title="Permalink"></a></h2><p>This is the original formulation where expressions like <code>(xA[t, i] - xA[t-1, i]) / dt</code> are repeated in multiple constraints.</p><pre><code class="language-julia hljs">function distillation_column_model(T = 3; backend = nothing)

    NT = 30
    FT = 17
    Ac = 0.5
    At = 0.25
    Ar = 1.0
    D = 0.2
    F = 0.4
    ybar = 0.8958
    ubar = 2.0
    alpha = 1.6
    dt = 10 / T
    xAf = 0.5
    xA0s = ExaModels.convert_array([(i, 0.5) for i = 0:(NT+1)], backend)

    itr0 = ExaModels.convert_array(collect(Iterators.product(1:T, 1:(FT-1))), backend)
    itr1 = ExaModels.convert_array(collect(Iterators.product(1:T, (FT+1):NT)), backend)
    itr2 = ExaModels.convert_array(collect(Iterators.product(0:T, 0:(NT+1))), backend)

    c = ExaCore(backend)

    xA = variable(c, 0:T, 0:(NT+1); start = 0.5)
    yA = variable(c, 0:T, 0:(NT+1); start = 0.5)
    u = variable(c, 0:T; start = 1.0)
    V = variable(c, 0:T; start = 1.0)
    L2 = variable(c, 0:T; start = 1.0)

    objective(c, (yA[t, 1] - ybar)^2 for t = 0:T)
    objective(c, (u[t] - ubar)^2 for t = 0:T)

    constraint(c, xA[0, i] - xA0 for (i, xA0) in xA0s)
    constraint(
        c,
        (xA[t, 0] - xA[t-1, 0]) / dt - (1 / Ac) * (yA[t, 1] - xA[t, 0]) for t = 1:T
    )
    constraint(
        c,
        (xA[t, i] - xA[t-1, i]) / dt -
        (1 / At) * (u[t] * D * (yA[t, i-1] - xA[t, i]) - V[t] * (yA[t, i] - yA[t, i+1])) for
        (t, i) in itr0
    )
    constraint(
        c,
        (xA[t, FT] - xA[t-1, FT]) / dt -
        (1 / At) * (
            F * xAf + u[t] * D * xA[t, FT-1] - L2[t] * xA[t, FT] -
            V[t] * (yA[t, FT] - yA[t, FT+1])
        ) for t = 1:T
    )
    constraint(
        c,
        (xA[t, i] - xA[t-1, i]) / dt -
        (1 / At) * (L2[t] * (yA[t, i-1] - xA[t, i]) - V[t] * (yA[t, i] - yA[t, i+1])) for
        (t, i) in itr1
    )
    constraint(
        c,
        (xA[t, NT+1] - xA[t-1, NT+1]) / dt -
        (1 / Ar) * (L2[t] * xA[t, NT] - (F - D) * xA[t, NT+1] - V[t] * yA[t, NT+1]) for
        t = 1:T
    )
    constraint(c, V[t] - u[t] * D - D for t = 0:T)
    constraint(c, L2[t] - u[t] * D - F for t = 0:T)
    constraint(
        c,
        yA[t, i] * (1 - xA[t, i]) - alpha * xA[t, i] * (1 - yA[t, i]) for (t, i) in itr2
    )

    return ExaModel(c)
end</code></pre><pre><code class="nohighlight hljs">distillation_column_model (generic function with 2 methods)</code></pre><h2 id="Model-with-Subexpressions-(Moderate)"><a class="docs-heading-anchor" href="#Model-with-Subexpressions-(Moderate)">Model with Subexpressions (Moderate)</a><a id="Model-with-Subexpressions-(Moderate)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-with-Subexpressions-(Moderate)" title="Permalink"></a></h2><p>Uses subexpressions for time derivatives and vapor differences. This adds auxiliary variables and constraints but makes the model more readable.</p><pre><code class="language-julia hljs">function distillation_column_model_with_subexpr(T = 3; backend = nothing)

    NT = 30
    FT = 17
    Ac = 0.5
    At = 0.25
    Ar = 1.0
    D = 0.2
    F = 0.4
    ybar = 0.8958
    ubar = 2.0
    alpha = 1.6
    dt = 10 / T
    xAf = 0.5
    xA0s = ExaModels.convert_array([(i, 0.5) for i in 0:(NT + 1)], backend)

    c = ExaCore(backend)

    # Decision variables
    xA = variable(c, 0:T, 0:(NT + 1); start = 0.5)
    yA = variable(c, 0:T, 0:(NT + 1); start = 0.5)
    u = variable(c, 0:T; start = 1.0)
    V = variable(c, 0:T; start = 1.0)
    L2 = variable(c, 0:T; start = 1.0)

    # Subexpressions - define common terms once
    dxA = subexpr(c, (xA[t, i] - xA[t - 1, i]) / dt for t in 1:T, i in 0:(NT + 1))
    dyA = subexpr(c, yA[t, i] - yA[t, i + 1] for t in 0:T, i in 0:NT)

    # Objectives
    objective(c, (yA[t, 1] - ybar)^2 for t in 0:T)
    objective(c, (u[t] - ubar)^2 for t in 0:T)

    # Initial conditions
    constraint(c, xA[0, i] - xA0 for (i, xA0) in xA0s)

    # Condenser - now using dxA subexpression
    constraint(c, dxA[t, 0] - (1 / Ac) * (yA[t, 1] - xA[t, 0]) for t in 1:T)

    # Rectifying section - cleaner with dxA and dyA
    itr_rect = ExaModels.convert_array(collect(Iterators.product(1:T, 1:(FT - 1))), backend)
    constraint(c, dxA[t, i] - (1 / At) * (u[t] * D * (yA[t, i - 1] - xA[t, i]) - V[t] * dyA[t, i]) for (t, i) in itr_rect)

    # Feed tray
    constraint(c, dxA[t, FT] - (1 / At) * (F * xAf + u[t] * D * xA[t, FT - 1] - L2[t] * xA[t, FT] - V[t] * dyA[t, FT]) for t in 1:T)

    # Stripping section
    itr_strip = ExaModels.convert_array(collect(Iterators.product(1:T, (FT + 1):NT)), backend)
    constraint(c, dxA[t, i] - (1 / At) * (L2[t] * (yA[t, i - 1] - xA[t, i]) - V[t] * dyA[t, i]) for (t, i) in itr_strip)

    # Reboiler
    constraint(c, dxA[t, NT + 1] - (1 / Ar) * (L2[t] * xA[t, NT] - (F - D) * xA[t, NT + 1] - V[t] * yA[t, NT + 1]) for t in 1:T)

    # Flow relationships
    constraint(c, V[t] - u[t] * D - D for t in 0:T)
    constraint(c, L2[t] - u[t] * D - F for t in 0:T)

    # VLE
    itr_vle = ExaModels.convert_array(collect(Iterators.product(0:T, 0:(NT + 1))), backend)
    constraint(c, yA[t, i] * (1 - xA[t, i]) - alpha * xA[t, i] * (1 - yA[t, i]) for (t, i) in itr_vle)

    return ExaModel(c)
end</code></pre><pre><code class="nohighlight hljs">distillation_column_model_with_subexpr (generic function with 2 methods)</code></pre><h2 id="Compact-Model-with-Aggressive-Subexpressions"><a class="docs-heading-anchor" href="#Compact-Model-with-Aggressive-Subexpressions">Compact Model with Aggressive Subexpressions</a><a id="Compact-Model-with-Aggressive-Subexpressions-1"></a><a class="docs-heading-anchor-permalink" href="#Compact-Model-with-Aggressive-Subexpressions" title="Permalink"></a></h2><p>This version uses subexpressions aggressively to maximize code clarity:</p><ul><li><code>V[t]</code> and <code>L2[t]</code> become subexpressions of <code>u[t]</code> (eliminates flow relationship constraints)</li><li><code>dxA[t,i]</code> captures time derivatives</li><li><code>VdyA[t,i]</code> captures vapor transport terms</li><li><code>uD[t]</code> captures the reflux flow term</li></ul><p><strong>Note:</strong> This model takes ~2x more iterations to converge (14 vs 7) due to the nested subexpression structure. All models reach the same optimal solution.</p><pre><code class="language-julia hljs">function distillation_column_model_compact(T = 3; backend = nothing)

    NT, FT = 30, 17
    Ac, At, Ar = 0.5, 0.25, 1.0
    D, F = 0.2, 0.4
    ybar, ubar, alpha = 0.8958, 2.0, 1.6
    dt, xAf = 10 / T, 0.5

    c = ExaCore(backend)

    # Primary decision variables (V and L2 eliminated!)
    xA = variable(c, 0:T, 0:(NT + 1); start = 0.5)
    yA = variable(c, 0:T, 0:(NT + 1); start = 0.5)
    u = variable(c, 0:T; start = 1.0)

    # Flow subexpressions (replaces V and L2 decision variables + constraints)
    V = subexpr(c, u[t] * D + D for t in 0:T)      ## Vapor flow = D(u+1)
    L2 = subexpr(c, u[t] * D + F for t in 0:T)     ## Liquid flow below feed

    # Time derivative of liquid composition
    dxA = subexpr(c, (xA[t, i] - xA[t - 1, i]) / dt for t in 1:T, i in 0:(NT + 1))

    # Vapor transport term V*(yA[t,i] - yA[t,i+1])
    VdyA = subexpr(c, V[t] * (yA[t, i] - yA[t, i + 1]) for t in 0:T, i in 0:NT)

    # Reflux term u*D
    uD = subexpr(c, u[t] * D for t in 0:T)

    # Objectives
    objective(c, (yA[t, 1] - ybar)^2 for t in 0:T)
    objective(c, (u[t] - ubar)^2 for t in 0:T)

    # Initial conditions
    xA0s = ExaModels.convert_array([(i, 0.5) for i in 0:(NT + 1)], backend)
    constraint(c, xA[0, i] - xA0 for (i, xA0) in xA0s)

    # Condenser (i=0): dxA/dt = (1/Ac)(yA[1] - xA[0])
    constraint(c, dxA[t, 0] - (1 / Ac) * (yA[t, 1] - xA[t, 0]) for t in 1:T)

    # Rectifying section (i=1 to FT-1): dxA/dt = (1/At)(uD*(yA[i-1]-xA[i]) - V*dyA)
    itr_rect = ExaModels.convert_array(collect(Iterators.product(1:T, 1:(FT - 1))), backend)
    constraint(c, dxA[t, i] - (1 / At) * (uD[t] * (yA[t, i - 1] - xA[t, i]) - VdyA[t, i]) for (t, i) in itr_rect)

    # Feed tray (i=FT)
    constraint(c, dxA[t, FT] - (1 / At) * (F * xAf + uD[t] * xA[t, FT - 1] - L2[t] * xA[t, FT] - VdyA[t, FT]) for t in 1:T)

    # Stripping section (i=FT+1 to NT)
    itr_strip = ExaModels.convert_array(collect(Iterators.product(1:T, (FT + 1):NT)), backend)
    constraint(c, dxA[t, i] - (1 / At) * (L2[t] * (yA[t, i - 1] - xA[t, i]) - VdyA[t, i]) for (t, i) in itr_strip)

    # Reboiler (i=NT+1)
    constraint(c, dxA[t, NT + 1] - (1 / Ar) * (L2[t] * xA[t, NT] - (F - D) * xA[t, NT + 1] - V[t] * yA[t, NT + 1]) for t in 1:T)

    # VLE: yA(1-xA) = α*xA(1-yA)
    itr_vle = ExaModels.convert_array(collect(Iterators.product(0:T, 0:(NT + 1))), backend)
    constraint(c, yA[t, i] * (1 - xA[t, i]) - alpha * xA[t, i] * (1 - yA[t, i]) for (t, i) in itr_vle)

    return ExaModel(c)
end</code></pre><pre><code class="nohighlight hljs">distillation_column_model_compact (generic function with 2 methods)</code></pre><h2 id="Model-with-Reduced-Subexpressions-(Moderate)"><a class="docs-heading-anchor" href="#Model-with-Reduced-Subexpressions-(Moderate)">Model with Reduced Subexpressions (Moderate)</a><a id="Model-with-Reduced-Subexpressions-(Moderate)-1"></a><a class="docs-heading-anchor-permalink" href="#Model-with-Reduced-Subexpressions-(Moderate)" title="Permalink"></a></h2><p>Uses <strong>reduced</strong> subexpressions for time derivatives and vapor differences. Unlike lifted subexpressions, reduced subexpressions do NOT add auxiliary variables or constraints - they inline the expression directly where used.</p><p>This gives the same problem size as the original model but with cleaner code.</p><pre><code class="language-julia hljs">function distillation_column_model_reduced(T = 3; backend = nothing)

    NT = 30
    FT = 17
    Ac = 0.5
    At = 0.25
    Ar = 1.0
    D = 0.2
    F = 0.4
    ybar = 0.8958
    ubar = 2.0
    alpha = 1.6
    dt = 10 / T
    xAf = 0.5
    xA0s = ExaModels.convert_array([(i, 0.5) for i in 0:(NT + 1)], backend)

    c = ExaCore(backend)

    # Decision variables (same as original)
    xA = variable(c, 0:T, 0:(NT + 1); start = 0.5)
    yA = variable(c, 0:T, 0:(NT + 1); start = 0.5)
    u = variable(c, 0:T; start = 1.0)
    V = variable(c, 0:T; start = 1.0)
    L2 = variable(c, 0:T; start = 1.0)

    # Reduced subexpressions - NO extra variables or constraints!
    # These inline the expression wherever they&#39;re used
    dxA = subexpr(c, (xA[t, i] - xA[t - 1, i]) / dt for t in 1:T, i in 0:(NT + 1); reduced = true)
    dyA = subexpr(c, yA[t, i] - yA[t, i + 1] for t in 0:T, i in 0:NT; reduced = true)

    # Objectives
    objective(c, (yA[t, 1] - ybar)^2 for t in 0:T)
    objective(c, (u[t] - ubar)^2 for t in 0:T)

    # Initial conditions
    constraint(c, xA[0, i] - xA0 for (i, xA0) in xA0s)

    # Condenser - using dxA reduced subexpression (inlines the derivative)
    constraint(c, dxA[t, 0] - (1 / Ac) * (yA[t, 1] - xA[t, 0]) for t in 1:T)

    # Rectifying section
    itr_rect = ExaModels.convert_array(collect(Iterators.product(1:T, 1:(FT - 1))), backend)
    constraint(c, dxA[t, i] - (1 / At) * (u[t] * D * (yA[t, i - 1] - xA[t, i]) - V[t] * dyA[t, i]) for (t, i) in itr_rect)

    # Feed tray
    constraint(c, dxA[t, FT] - (1 / At) * (F * xAf + u[t] * D * xA[t, FT - 1] - L2[t] * xA[t, FT] - V[t] * dyA[t, FT]) for t in 1:T)

    # Stripping section
    itr_strip = ExaModels.convert_array(collect(Iterators.product(1:T, (FT + 1):NT)), backend)
    constraint(c, dxA[t, i] - (1 / At) * (L2[t] * (yA[t, i - 1] - xA[t, i]) - V[t] * dyA[t, i]) for (t, i) in itr_strip)

    # Reboiler
    constraint(c, dxA[t, NT + 1] - (1 / Ar) * (L2[t] * xA[t, NT] - (F - D) * xA[t, NT + 1] - V[t] * yA[t, NT + 1]) for t in 1:T)

    # Flow relationships (still needed as these are decision variables)
    constraint(c, V[t] - u[t] * D - D for t in 0:T)
    constraint(c, L2[t] - u[t] * D - F for t in 0:T)

    # VLE
    itr_vle = ExaModels.convert_array(collect(Iterators.product(0:T, 0:(NT + 1))), backend)
    constraint(c, yA[t, i] * (1 - xA[t, i]) - alpha * xA[t, i] * (1 - yA[t, i]) for (t, i) in itr_vle)

    return ExaModel(c)
end</code></pre><pre><code class="nohighlight hljs">distillation_column_model_reduced (generic function with 2 methods)</code></pre><h2 id="Compact-Model-with-Aggressive-Reduced-Subexpressions"><a class="docs-heading-anchor" href="#Compact-Model-with-Aggressive-Reduced-Subexpressions">Compact Model with Aggressive Reduced Subexpressions</a><a id="Compact-Model-with-Aggressive-Reduced-Subexpressions-1"></a><a class="docs-heading-anchor-permalink" href="#Compact-Model-with-Aggressive-Reduced-Subexpressions" title="Permalink"></a></h2><p>This version uses <strong>reduced</strong> subexpressions aggressively:</p><ul><li><code>V[t]</code> and <code>L2[t]</code> become reduced subexpressions of <code>u[t]</code> (eliminates V and L2 as decision variables!)</li><li><code>dxA[t,i]</code> captures time derivatives (reduced)</li><li><code>VdyA[t,i]</code> captures vapor transport terms (reduced, nests V)</li><li><code>uD[t]</code> captures the reflux flow term (reduced)</li></ul><p>This results in FEWER variables than the original (no V, L2 decision variables) while keeping the same convergence behavior.</p><pre><code class="language-julia hljs">function distillation_column_model_compact_reduced(T = 3; backend = nothing)

    NT, FT = 30, 17
    Ac, At, Ar = 0.5, 0.25, 1.0
    D, F = 0.2, 0.4
    ybar, ubar, alpha = 0.8958, 2.0, 1.6
    dt, xAf = 10 / T, 0.5

    c = ExaCore(backend)

    # Primary decision variables (V and L2 eliminated via reduced subexpressions!)
    xA = variable(c, 0:T, 0:(NT + 1); start = 0.5)
    yA = variable(c, 0:T, 0:(NT + 1); start = 0.5)
    u = variable(c, 0:T; start = 1.0)

    # Reduced flow subexpressions (replaces V and L2 decision variables + their constraints!)
    V = subexpr(c, u[t] * D + D for t in 0:T; reduced = true)      ## Vapor flow = D(u+1)
    L2 = subexpr(c, u[t] * D + F for t in 0:T; reduced = true)     ## Liquid flow below feed

    # Reduced time derivative
    dxA = subexpr(c, (xA[t, i] - xA[t - 1, i]) / dt for t in 1:T, i in 0:(NT + 1); reduced = true)

    # Reduced vapor transport term V*(yA[t,i] - yA[t,i+1]) - nests V!
    VdyA = subexpr(c, V[t] * (yA[t, i] - yA[t, i + 1]) for t in 0:T, i in 0:NT; reduced = true)

    # Reduced reflux term u*D
    uD = subexpr(c, u[t] * D for t in 0:T; reduced = true)

    # Objectives
    objective(c, (yA[t, 1] - ybar)^2 for t in 0:T)
    objective(c, (u[t] - ubar)^2 for t in 0:T)

    # Initial conditions
    xA0s = ExaModels.convert_array([(i, 0.5) for i in 0:(NT + 1)], backend)
    constraint(c, xA[0, i] - xA0 for (i, xA0) in xA0s)

    # Condenser (i=0)
    constraint(c, dxA[t, 0] - (1 / Ac) * (yA[t, 1] - xA[t, 0]) for t in 1:T)

    # Rectifying section (i=1 to FT-1)
    itr_rect = ExaModels.convert_array(collect(Iterators.product(1:T, 1:(FT - 1))), backend)
    constraint(c, dxA[t, i] - (1 / At) * (uD[t] * (yA[t, i - 1] - xA[t, i]) - VdyA[t, i]) for (t, i) in itr_rect)

    # Feed tray (i=FT)
    constraint(c, dxA[t, FT] - (1 / At) * (F * xAf + uD[t] * xA[t, FT - 1] - L2[t] * xA[t, FT] - VdyA[t, FT]) for t in 1:T)

    # Stripping section (i=FT+1 to NT)
    itr_strip = ExaModels.convert_array(collect(Iterators.product(1:T, (FT + 1):NT)), backend)
    constraint(c, dxA[t, i] - (1 / At) * (L2[t] * (yA[t, i - 1] - xA[t, i]) - VdyA[t, i]) for (t, i) in itr_strip)

    # Reboiler (i=NT+1)
    constraint(c, dxA[t, NT + 1] - (1 / Ar) * (L2[t] * xA[t, NT] - (F - D) * xA[t, NT + 1] - V[t] * yA[t, NT + 1]) for t in 1:T)

    # VLE: yA(1-xA) = α*xA(1-yA)
    itr_vle = ExaModels.convert_array(collect(Iterators.product(0:T, 0:(NT + 1))), backend)
    constraint(c, yA[t, i] * (1 - xA[t, i]) - alpha * xA[t, i] * (1 - yA[t, i]) for (t, i) in itr_vle)

    return ExaModel(c)
end</code></pre><pre><code class="nohighlight hljs">distillation_column_model_compact_reduced (generic function with 2 methods)</code></pre><h2 id="Running-the-Models"><a class="docs-heading-anchor" href="#Running-the-Models">Running the Models</a><a id="Running-the-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-Models" title="Permalink"></a></h2><p>Let&#39;s compare all five model variants and verify they converge to the same solution.</p><pre><code class="language-julia hljs">using ExaModels, NLPModelsIpopt

T_val = 10</code></pre><pre><code class="nohighlight hljs">10</code></pre><ol><li>Original model (no subexpressions)</li></ol><pre><code class="language-julia hljs">m_orig = distillation_column_model(T_val)
result_orig = ipopt(m_orig; print_level = 0)</code></pre><pre><code class="nohighlight hljs">&quot;Execution stats: first-order stationary&quot;</code></pre><ol><li>Moderate lifted subexpressions</li></ol><pre><code class="language-julia hljs">m_lifted_mod = distillation_column_model_with_subexpr(T_val)
result_lifted_mod = ipopt(m_lifted_mod; print_level = 0)</code></pre><pre><code class="nohighlight hljs">&quot;Execution stats: first-order stationary&quot;</code></pre><ol><li>Aggressive lifted subexpressions</li></ol><pre><code class="language-julia hljs">m_lifted_agg = distillation_column_model_compact(T_val)
result_lifted_agg = ipopt(m_lifted_agg; print_level = 0)</code></pre><pre><code class="nohighlight hljs">&quot;Execution stats: first-order stationary&quot;</code></pre><ol><li>Moderate reduced subexpressions</li></ol><pre><code class="language-julia hljs">m_reduced_mod = distillation_column_model_reduced(T_val)
result_reduced_mod = ipopt(m_reduced_mod; print_level = 0)</code></pre><pre><code class="nohighlight hljs">&quot;Execution stats: first-order stationary&quot;</code></pre><ol><li>Aggressive reduced subexpressions</li></ol><pre><code class="language-julia hljs">m_reduced_agg = distillation_column_model_compact_reduced(T_val)
result_reduced_agg = ipopt(m_reduced_agg; print_level = 0)</code></pre><pre><code class="nohighlight hljs">&quot;Execution stats: first-order stationary&quot;</code></pre><h2 id="Comparison-Results"><a class="docs-heading-anchor" href="#Comparison-Results">Comparison Results</a><a id="Comparison-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-Results" title="Permalink"></a></h2><p>Print comparison table:</p><pre><code class="language-julia hljs">println(&quot;=&quot;^70)
println(&quot;Distillation Column Model Comparison (T=$T_val)&quot;)
println(&quot;=&quot;^70)
println()
println(&quot;| Model                  | Variables | Constraints | Iterations | Objective |&quot;)
println(&quot;|------------------------|-----------|-------------|------------|-----------|&quot;)
println(&quot;| Original (no subexpr)  | $(lpad(m_orig.meta.nvar, 9)) | $(lpad(m_orig.meta.ncon, 11)) | $(lpad(result_orig.iter, 10)) | $(round(result_orig.objective, digits = 6)) |&quot;)
println(&quot;| Moderate lifted        | $(lpad(m_lifted_mod.meta.nvar, 9)) | $(lpad(m_lifted_mod.meta.ncon, 11)) | $(lpad(result_lifted_mod.iter, 10)) | $(round(result_lifted_mod.objective, digits = 6)) |&quot;)
println(&quot;| Aggressive lifted      | $(lpad(m_lifted_agg.meta.nvar, 9)) | $(lpad(m_lifted_agg.meta.ncon, 11)) | $(lpad(result_lifted_agg.iter, 10)) | $(round(result_lifted_agg.objective, digits = 6)) |&quot;)
println(&quot;| Moderate reduced       | $(lpad(m_reduced_mod.meta.nvar, 9)) | $(lpad(m_reduced_mod.meta.ncon, 11)) | $(lpad(result_reduced_mod.iter, 10)) | $(round(result_reduced_mod.objective, digits = 6)) |&quot;)
println(&quot;| Aggressive reduced     | $(lpad(m_reduced_agg.meta.nvar, 9)) | $(lpad(m_reduced_agg.meta.ncon, 11)) | $(lpad(result_reduced_agg.iter, 10)) | $(round(result_reduced_agg.objective, digits = 6)) |&quot;)
println()</code></pre><pre><code class="nohighlight hljs">======================================================================
Distillation Column Model Comparison (T=10)
======================================================================

| Model                  | Variables | Constraints | Iterations | Objective |
|------------------------|-----------|-------------|------------|-----------|
| Original (no subexpr)  |       737 |         726 |          7 | 0.15107 |
| Moderate lifted        |      1398 |        1387 |          7 | 0.15107 |
| Aggressive lifted      |      1409 |        1398 |         14 | 0.15107 |
| Moderate reduced       |       737 |         726 |          7 | 0.15107 |
| Aggressive reduced     |       715 |         704 |          7 | 0.15107 |

</code></pre><p>Verify all models converge to the same solution:</p><pre><code class="language-julia hljs">all_same = all(
    [
        isapprox(result_orig.objective, result_lifted_mod.objective, rtol = 1.0e-4),
        isapprox(result_orig.objective, result_lifted_agg.objective, rtol = 1.0e-4),
        isapprox(result_orig.objective, result_reduced_mod.objective, rtol = 1.0e-4),
        isapprox(result_orig.objective, result_reduced_agg.objective, rtol = 1.0e-4),
    ]
)

println(&quot;All models converge to same objective: $all_same&quot;)</code></pre><pre><code class="nohighlight hljs">All models converge to same objective: true
</code></pre><p>Key observations:</p><ul><li>Lifted subexpressions ADD variables/constraints (auxiliary vars + defining constraints)</li><li>Reduced subexpressions maintain or REDUCE problem size (no aux vars)</li><li>Aggressive reduced eliminates V and L2 as decision variables entirely!</li><li>All models reach the same optimal solution</li></ul><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quad/">« Example: Quadrotor</a><a class="docs-footer-nextpage" href="../opf/">Example: Optimal Power Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 15 December 2025 15:26">Monday 15 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
